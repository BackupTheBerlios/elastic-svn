#include <stdlib.h>
#include <stdio.h>

#include "defs.h"

#define ELASTIC_PACKAGE    "@ELASTIC_PACKAGE@"
#define ELASTIC_CLASS_DECL "@ELASTIC_CLASS_DECL@"

/*  The banner used here should be replaced with an #ident directive	*/
/*  if the target C compiler supports #ident directives.		*/
/*									*/
/*  If the skeleton is changed, the banner should be changed so that	*/
/*  the altered version can easily be distinguished from the original.	*/

char *banner[] = {
	"#if defined(__STDC__) || defined(__cplusplus)",
	"#define YYCONST const",
	"#define YYPARAMS(x) x",
	"#define YYDEFUN(name, arglist, args) name(args)",
	"#define YYAND ,",
	"#define YYPTR void *",
	"#else",
	"#define YYCONST",
	"#define YYPARAMS(x) ()",
	"#define YYDEFUN(name, arglist, args) name arglist args;",
	"#define YYAND ;",
	"#define YYPTR char *",
	"#endif",
	"#ifndef lint",
	"YYCONST static char yysccsid[] = \"@(#)yaccpar	1.8 (Berkeley +Cygnus.28) 01/20/91\";",
	"#endif",
	"#define YYBYACC 1",
	/* FIXME: bison always includes stdio.h, this seems unnecessary.  */
	"#ifndef YYDONT_INCLUDE_STDIO",
	"#include <stdio.h>",
	"#endif",
	"#ifdef __cplusplus",
	"#include <stdlib.h> /* for malloc/realloc/free */",
	"#endif",
	0
};

char *ec_banner[] = {
	"//### This file created by byacc 1.8 / elastiC extension 0.1)",
	"//### elastiC support added 8 Oct 2001, Marco Pantaleoni",
	"//### Please send bug reports to panta@elasticworld.org",
	"//### private yysccsid = \"@(#)yaccpar	1.8 (Berkeley +Cygnus.28) 01/20/91\";",
	"\n\n",
	ELASTIC_PACKAGE,
	"\n\n",
	0
};



char *tables[] = {
	/*$"extern short yylhs[];",
	 * "extern short yylen[];",FIXME$ */
	/*$"extern short yydefred[];",FIXME$ */
	/*$"extern short yydgoto[];",FIXME$ */
	/*$"extern short yysindex[];",
	 * "extern short yyrindex[];",
	 * "extern short yygindex[];",FIXME$ */
	/*$"extern short yytable[];", FIXME $ */
	/*$"extern short yycheck[];",FIXME$ */
	"#if YYDEBUG",
	/*$"extern char *yyname[];",FIXME$ */
	/*$"extern char *yyrule[];",FIXME$ */
	"#endif",
	0
};

char *ec_tables[] = {
	"",
	0
};


char *header[] = {
	"#define YYLEX yylex()",
	"#define YYEMPTY -1",
	"#define yyclearin (yychar=(YYEMPTY))",
	"#define yyerrok (yyerrflag=0)",
	"#ifndef YYINITDEPTH",
	"#define YYINITDEPTH 200",
	"#endif",
	"#ifdef YYSTACKSIZE",
	"#ifndef YYMAXDEPTH",
	"#define YYMAXDEPTH YYSTACKSIZE",
	"#endif",
	"#else",
	"#ifdef YYMAXDEPTH",
	"#define YYSTACKSIZE YYMAXDEPTH",
	"#else",
	"#define YYSTACKSIZE 500",
	"#define YYMAXDEPTH 500",
	"#endif",
	"#endif",
	"#ifndef YYMAXSTACKSIZE",
	"#define YYMAXSTACKSIZE 10000",
	"#endif",
	"int yydebug;",
	"int yynerrs;",
	"int yyerrflag;",
	"int yychar;",
	"YYSTYPE yyval;",
	"YYSTYPE yylval;",
	"static short *yyss;",
	"static YYSTYPE *yyvs;",
	"static int yystacksize;",
	"#define yyfree(x) free(x)",
	"extern int yylex();",
	"",
	"static YYPTR",
	"YYDEFUN (yymalloc, (bytes), unsigned bytes)",
	"{",
	"    YYPTR ptr = (YYPTR) malloc (bytes);",
	"    if (ptr != 0) return (ptr);",
	"    yyerror (\"yyparse: memory exhausted\");",
	"    return (0);",
	"}",
	"",
	"static YYPTR",
	"YYDEFUN (yyrealloc, (old, bytes), YYPTR old YYAND unsigned bytes)",
	"{",
	"    YYPTR ptr = (YYPTR) realloc (old, bytes);",
	"    if (ptr != 0) return (ptr);",
	"    yyerror (\"yyparse: memory exhausted\");",
	"    return (0);",
	"}",
	"",
	"static int",
	"#ifdef __GNUC__",
	"__inline__",
	"#endif",
	"yygrow ()",
	"{",
	"    int old_stacksize = yystacksize;",
	"    short *new_yyss;",
	"    YYSTYPE *new_yyvs;",
	"",
	"    if (yystacksize == YYMAXSTACKSIZE)",
	"        return (1);",
	"    yystacksize += (yystacksize + 1 ) / 2;",
	"    if (yystacksize > YYMAXSTACKSIZE)",
	"        yystacksize = YYMAXSTACKSIZE;",
	"#if YYDEBUG",
	"    if (yydebug)",
	"        printf(\"yydebug: growing stack size from %d to %d\\n\",",
	"               old_stacksize, yystacksize);",
	"#endif",
	"    new_yyss = (short *) yyrealloc ((char *)yyss, yystacksize * sizeof (short));",
	"    if (new_yyss == 0)",
	"        return (1);",
	"    new_yyvs = (YYSTYPE *) yyrealloc ((char *)yyvs, yystacksize * sizeof (YYSTYPE));",
	"    if (new_yyvs == 0)",
	"    {",
	"        yyfree (new_yyss);",
	"        return (1);",
	"    }",
	"    yyss = new_yyss;",
	"    yyvs = new_yyvs;",
	"    return (0);",
	"}",
	0
};

char *ec_header[] = {
	"\n\n\n",
	"/*",
	" * Encapsulates yacc() parser functionality in an elastiC class",
	" */",
	ELASTIC_CLASS_DECL,
	"{\n",
	"local yydebug;        // (boolean) debug output desired ?",
	"local yynerrs;        // (int)     number of errors so far",
	"local yyerrflag;      // (int)     was there an error ?",
	"local yychar;         // (int)     the current working character",
	"\n//########## MESSAGES ##########",
	"//###############################################################",
	"// method: debug",
	"//###############################################################",
	"method debug(msg)",
	"{",
	"  if (yydebug)",
	"    basic.print(msg, '\\n');",
	"}",
	"method yyerror(msg)",
	"{",
	"    basic.print(\"ERROR: \", msg, '\\n');",
	"}",
	"\n//########## STATE STACK ##########",
	"\nlocal statestk, stateptr;          // (int[], int) state stack",
	"local stateptrmax;                   // (int)        highest index of stackptr",
	"local statemax;                      // (int)        state when highest index reached",
	"//###############################################################",
	"// methods: state stack push,pop,drop,peek",
	"//###############################################################",
	"method state_push(state)",
	"{",
	"  statestk[++stateptr] = state;",
	"  if (stateptr > statemax)",
	"    {",
	"    statemax = state;",
	"    stateptrmax = stateptr;",
	"    }",
	"}",
	"method state_pop()",
	"{",
	"  if (stateptr < 0)                 //underflowed?",
	"    return -1;",
	"  return statestk[stateptr--];",
	"}",
	"method state_drop(cnt)",
	"{",
	"  local ptr;",
	"  ptr = stateptr - cnt;",
	"  if (ptr < 0)",
	"    return;",
	"  stateptr = ptr;",
	"}",
	"method state_peek(relative)",
	"{",
	"  local ptr;",
	"  ptr = stateptr - relative;",
	"  if (ptr < 0)",
	"    return -1;",
	"  return statestk[ptr];",
	"}",
	"//###############################################################",
	"// method: init_stacks : allocate and prepare stacks",
	"//###############################################################",
	"method init_stacks()",
	"{",
	"  statestk = #[];",
	"  stateptr = -1;",
	"  statemax = -1;",
	"  stateptrmax = -1;",
	"  [self val_init];",
	"  return @true;",
	"}",
	"//###############################################################",
	"// method: dump_stacks : show n levels of the stacks",
	"//###############################################################",
	"method dump_stacks(count)",
	"{",
	"  local i;",
	"  basic.print(\"=index==state====value=     s:\"+stateptr+\"  v:\"+[self get_valptr], '\\n');",
	"  for (i = 0 ; i < count; i++)",
	"    basic.print(\" \"+i+\"    \"+statestk[i]+\"      \"+[self get_valstk][i], '\\n');",
	"  basic.print(\"======================\\n\");",
	"}",
	0
};


char *body[] = {
	"#define YYABORT goto yyabort",
	"#define YYACCEPT goto yyaccept",
	"#define YYERROR goto yyerrlab",
	"",
	"#if YYDEBUG",
	"#ifdef __cplusplus",
	"extern \"C\" char *getenv();",
	"#else",
	"extern char *getenv();",
	"#endif",
	"#endif",
	"",
	"int",
	"yyparse()",
	"{",
	"    register int yym, yyn, yystate;",
	"    register YYSTYPE *yyvsp;",
	"    register short *yyssp;",
	"    short *yysse;",
	"#if YYDEBUG",
	"    register YYCONST char *yys;",
	"",
	"    if (yys = getenv(\"YYDEBUG\"))",
	"    {",
	"        yyn = *yys;",
	"        if (yyn >= '0' && yyn <= '9')",
	"            yydebug = yyn - '0';",
	"    }",
	"#endif",
	"",
	"    yynerrs = 0;",
	"    yyerrflag = 0;",
	"    yychar = (-1);",
	"",
	"    if (yyss == 0)",
	"    {",
	"        yyss = (short *) yymalloc (YYSTACKSIZE * sizeof (short));",
	"        if (yyss == 0)",
	"          goto yyabort;",
	"        yyvs = (YYSTYPE *) yymalloc (YYSTACKSIZE * sizeof (YYSTYPE));",
	"        if (yyvs == 0)",
	"        {",
	"            yyfree (yyss);",
	"            goto yyabort;",
	"        }",
	"        yystacksize = YYSTACKSIZE;",
	"    }",
	"    yysse = yyss + yystacksize - 1;",
	"    yyssp = yyss;",
	"    yyvsp = yyvs;",
	"    *yyssp = yystate = 0;",
	"    goto yyloop;",
	"",
	"yypush_lex:",
	"    yyval = yylval;",
	"    yystate = yytable[yyn];",
	"yypush:",
	"    if (yyssp >= yysse)",
	"    {",
	"        int depth = yyssp - yyss;",
	"        if (yygrow() != 0)",
	"             goto yyoverflow;",
	"        yysse = yyss + yystacksize -1;",
	"        yyssp = depth + yyss;",
	"        yyvsp = depth + yyvs;",
	"    }",
	"    *++yyssp = yystate;",
	"    *++yyvsp = yyval;",
	"",
	"yyloop:",
	"    if (yyn = yydefred[yystate]) goto yyreduce;",
	"    yyn = yysindex[yystate];",
	"    if (yychar < 0)",
	"    {",
	"        if ((yychar = yylex()) < 0) yychar = 0;",
	"#if YYDEBUG",
	"        if (yydebug)",
	"        {",
	"            yys = 0;",
	"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"            if (!yys) yys = \"illegal-symbol\";",
	"            printf(\"yydebug: state %d, reading %d (%s)\\n\", yystate,",
	"                    yychar, yys);",
	"        }",
	"#endif",
	"    }",
	"    if (yyn != 0",
	"        && ((yyn += yychar), ((unsigned)yyn <= (unsigned)YYTABLESIZE))",
	"        && yycheck[yyn] == yychar)",
	"    {",
	"#if YYDEBUG",
	"        if (yydebug)",
	"            printf(\"yydebug: state %d, shifting to state %d\\n\",",
	"                    yystate, yytable[yyn]);",
	"#endif",
	"        if (yyerrflag > 0)  --yyerrflag;",
	"        yychar = (-1);",
	"        goto yypush_lex;",
	"    }",
	"    yyn = yyrindex[yystate];",
	"    if (yyn != 0",
	"        && ((yyn += yychar), ((unsigned)yyn <= (unsigned)YYTABLESIZE))",
	"        && yycheck[yyn] == yychar)",
	"    {",
	"        yyn = yytable[yyn];",
	"        goto yyreduce;",
	"    }",
	"    if (yyerrflag) goto yyinrecovery;",
	"#ifdef lint",
	"    goto yynewerror;",
	"#endif",
	"yynewerror:",
	"    yyerror(\"syntax error\");",
	"#ifdef lint",
	"    goto yyerrlab;",
	"#endif",
	"yyerrlab:",
	"    ++yynerrs;",
	"yyinrecovery:",
	"    if (yyerrflag < 3)",
	"    {",
	"        yyerrflag = 3;",
	"        for (;;)",
	"        {",
	"            yyn = yysindex[*yyssp];",
	"            if (yyn != 0",
	"                && ((yyn += YYERRCODE), ((unsigned)yyn <= (unsigned)YYTABLESIZE))",
	"                && yycheck[yyn] == YYERRCODE)",
	"            {",
	"#if YYDEBUG",
	"                if (yydebug)",
	"                    printf(\"yydebug: state %d, error recovery shifting\\",
	" to state %d\\n\", *yyssp, yytable[yyn]);",
	"#endif",
	"                goto yypush_lex;",
	"            }",
	"            else",
	"            {",
	"#if YYDEBUG",
	"                if (yydebug)",
	"                    printf(\"yydebug: error recovery discarding state %d\
\\n\",",
	"                            *yyssp);",
	"#endif",
	"                if (yyssp <= yyss) goto yyabort;",
	"                --yyssp;",
	"                --yyvsp;",
	"            }",
	"        }",
	"    }",
	"    else",
	"    {",
	"        if (yychar == 0) goto yyabort;",
	"#if YYDEBUG",
	"        if (yydebug)",
	"        {",
	"            yys = 0;",
	"            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"            if (!yys) yys = \"illegal-symbol\";",
	"            printf(\"yydebug: state %d, error recovery discards token %d\
 (%s)\\n\",",
	"                    yystate, yychar, yys);",
	"        }",
	"#endif",
	"        yychar = (-1);",
	"        goto yyloop;",
	"    }",
	"yyreduce:",
	"#if YYDEBUG",
	"    if (yydebug)",
	"        printf(\"yydebug: state %d, reducing by rule %d (%s)\\n\",",
	"                yystate, yyn, yyrule[yyn]);",
	"#endif",
	"    yym = yylen[yyn];",
	"    yyval = yyvsp[1-yym];",
	"    switch (yyn)",
	"    {",
	0
};

char *ec_body[] = {
	"//###############################################################",
	"// method: yylexdebug : check lexer state",
	"//###############################################################",
	"method yylexdebug(state, ch)",
	"{",
	"  local s = @nil;",
	"  if (ch < 0) ch = 0;",
	"  if (ch <= YYMAXTOKEN) //check index bounds",
	"     s = yyname[ch];    //now get it",
	"  if (s == @nil)",
	"    s = \"illegal-symbol\";",
	"  [self debug \"state \"+basic.repr(state)+\", reading \"+basic.repr(ch)+\" (\"+basic.repr(s)+\")\"];",
	"}\n\n\n",
	"\n",
	"//The following are now global, to aid in error reporting",
	"local yyn;       // (int) next next thing to do",
	"local yym;       // (int)",
	"local yystate;   // (int) current parsing state from state table",
	"local yys;       // (string) current token string",
	"\n",
	"//###############################################################",
	"// method: yyparse : parse input and execute indicated items",
	"//###############################################################",
	"method yyparse()",
	"{",
	"  local doaction; // (boolean)",
	"  [self init_stacks];",
	"  yynerrs = 0;",
	"  yyerrflag = 0;",
	"  yychar = -1;          //impossible char forces a read",
	"  yystate=0;            //initial state",
	"  [self state_push yystate];  //save it",
	"  while (@true) //until parsing is done, either correctly, or w/error",
	"    {",
	"    doaction=@true;",
	"    if (yydebug) [self debug \"loop\"]; ",
	"    //#### NEXT ACTION (from reduction table)",
	"    for (yyn=yydefred[yystate];yyn==0;yyn=yydefred[yystate])",
	"      {",
	"      if (yydebug) [self debug \"yyn:\"+basic.repr(yyn)+\"  state:\"+basic.repr(yystate)+\"  yychar:\"+basic.repr(yychar)];",
	"      if (basic.int(yychar) < 0)      //we want a char?",
	"        {",
	"        yychar = [self yylex];  //get next token",
	"        if (yydebug) [self debug \" next yychar:\"+basic.repr(yychar)];",
	"        //#### ERROR CHECK ####",
	"        if (basic.int(yychar) < 0)    //it it didn't work/error",
	"          {",
	"          yychar = 0;      //change it to default string (no -1!)",
	"          if (yydebug)",
	"            [self yylexdebug yystate, yychar];",
	"          }",
	"        }//yychar<0",
	"      yyn = yysindex[yystate];  //get amount to shift by (shift index)",
	"      if ((yyn != 0) && (yyn += basic.int(yychar)) >= 0 &&",
	"          yyn <= YYTABLESIZE && yycheck[yyn] == basic.int(yychar))",
	"        {",
	"        if (yydebug)",
	"          [self debug \"state \"+basic.repr(yystate)+\", shifting to state \"+basic.repr(yytable[yyn])];",
	"        //#### NEXT STATE ####",
	"        yystate = yytable[yyn];//we are in a new state",
	"        [self state_push yystate];   //save it",
	"        [self val_push yylval];      //push our lval as the input for next rule",
	"        yychar = -1;           //since we have 'eaten' a token, say we need another",
	"        if (yyerrflag > 0)     //have we recovered an error?",
	"           --yyerrflag;        //give ourselves credit",
	"        doaction=@false;        //but don't process yet",
	"        break;   //quit the yyn=0 loop",
	"        }",
	"",
	"    yyn = yyrindex[yystate];  //reduce",
	"    if ((yyn !=0 ) && (yyn += basic.int(yychar)) >= 0 &&",
	"            yyn <= YYTABLESIZE && yycheck[yyn] == basic.int(yychar))",
	"      {   //we reduced!",
	"      if (yydebug) [self debug \"reduce\"];",
	"      yyn = yytable[yyn];",
	"      doaction=@true; //get ready to execute",
	"      break;         //drop down to actions",
	"      }",
	"    else //ERROR RECOVERY",
	"      {",
	"      if (yyerrflag==0)",
	"        {",
	"        [self yyerror \"syntax error\"];",
	"        yynerrs++;",
	"        }",
	"      if (yyerrflag < 3) //low error count?",
	"        {",
	"        yyerrflag = 3;",
	"        while (@true)   //do until break",
	"          {",
	"          if (stateptr<0)   //check for under & overflow here",
	"            {",
	"            [self yyerror \"stack underflow. aborting...\"];  //note lower case 's'",
	"            return 1;",
	"            }",
	"          yyn = yysindex[[self state_peek 0]];",
	"          if ((yyn != 0) && (yyn += YYERRCODE) >= 0 &&",
	"                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)",
	"            {",
	"            if (yydebug)",
	"              [self debug \"state \"+basic.repr([self state_peek 0])+\", error recovery shifting to state \"+basic.repr(yytable[yyn])+\" \"];",
	"            yystate = yytable[yyn];",
	"            [self state_push yystate];",
	"            [self val_push yylval];",
	"            doaction=@false;",
	"            break;",
	"            }",
	"          else",
	"            {",
	"            if (yydebug)",
	"              [self debug \"error recovery discarding state \"+basic.repr([self state_peek 0])+\" \"];",
	"            if (stateptr<0)   //check for under & overflow here",
	"              {",
	"              [self yyerror \"Stack underflow. aborting...\"];  //capital 'S'",
	"              return 1;",
	"              }",
	"            [self state_pop];",
	"            [self val_pop];",
	"            }",
	"          }",
	"        }",
	"      else            //discard this token",
	"        {",
	"        if (basic.int(yychar) == 0)",
	"          return 1; //yyabort",
	"        if (yydebug)",
	"          {",
	"          yys = @nil;",
	"          if (basic.int(yychar) <= YYMAXTOKEN) yys = yyname[basic.int(yychar)];",
	"          if (yys == @nil) yys = \"illegal-symbol\";",
	"          [self debug \"state \"+basic.repr(yystate)+\", error recovery discards token \"+basic.repr(yychar)+\" (\"+basic.repr(yys)+\")\"];",
	"          }",
	"        yychar = -1;  //read another",
	"        }",
	"      }//end error recovery",
	"    }//yyn=0 loop",
	"    if (!doaction)   //any reason not to proceed?",
	"      continue;      //skip action",
	"    yym = yylen[yyn];          //get count of terminals on rhs",
	"    if (yydebug)",
	"      [self debug \"state \"+basic.repr(yystate)+\", reducing \"+basic.repr(yym)+\" by rule \"+basic.repr(yyn)+\" (\"+basic.repr(yyrule[yyn])+\")\"];",
	"    if (yym>0)                 //if count of rhs not 'nil'",
	"      yyval = [self val_peek yym-1]; //get current semantic value",
	"    /* switch(yyn) */",
	"      {",
	"//########## USER-SUPPLIED ACTIONS ##########",
	0
};


char *trailer[] = {
	"    }",
	"    yyssp -= yym;",
	"    yyvsp -= yym;",
	"    yym = yylhs[yyn];",
	"    yystate = *yyssp;",
	"    if (yystate == 0 && yym == 0)",
	"    {",
	"#if YYDEBUG",
	"        if (yydebug)",
	"            printf(\"yydebug: after reduction, shifting from state 0 to\\",
	" state %d\\n\", YYFINAL);",
	"#endif",
	"        yystate = YYFINAL;",
	"        *++yyssp = YYFINAL;",
	"        *++yyvsp = yyval;",
	"        if (yychar < 0)",
	"        {",
	"            if ((yychar = yylex()) < 0) yychar = 0;",
	"#if YYDEBUG",
	"            if (yydebug)",
	"            {",
	"                yys = 0;",
	"                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];",
	"                if (!yys) yys = \"illegal-symbol\";",
	"                printf(\"yydebug: state %d, reading %d (%s)\\n\",",
	"                        YYFINAL, yychar, yys);",
	"            }",
	"#endif",
	"        }",
	"        if (yychar == 0) goto yyaccept;",
	"        goto yyloop;",
	"    }",
	"    yyn = yygindex[yym];",
	"	 if (yyn != 0",
	"        && ((yyn += yystate), ((unsigned)yyn <= (unsigned)YYTABLESIZE))",
	"        && yycheck[yyn] == yystate)",
	"        yystate = yytable[yyn];",
	"    else",
	"        yystate = yydgoto[yym];",
	"#if YYDEBUG",
	"    if (yydebug)",
	"        printf(\"yydebug: after reduction, shifting from state %d \\",
	"to state %d\\n\", *yyssp, yystate);",
	"#endif",
	"    goto yypush;",
	"yyoverflow:",
	"    yyerror(\"yacc stack overflow\");",
	"yyabort:",
	"    return (1);",
	"yyaccept:",
	"    return (0);",
	"}",
	0
};

char *ec_trailer[] = {
	"//########## END OF USER-SUPPLIED ACTIONS ##########",
	"    }//switch",
	"    //#### Now let's reduce... ####",
	"    if (yydebug) [self debug \"reduce\"];",
	"    [self state_drop yym];             //we just reduced yylen states",
	"    yystate = [self state_peek 0];     //get new state",
	"    [self val_drop yym];               //corresponding value drop",
	"    yym = yylhs[yyn];            //select next TERMINAL(on lhs)",
	"    if (yystate == 0 && yym == 0)//done? 'rest' state and at first TERMINAL",
	"      {",
	"      [self debug \"After reduction, shifting from state 0 to state \"+basic.repr(YYFINAL)+\"\"];",
	"      yystate = YYFINAL;         //explicitly say we're done",
	"      [self state_push YYFINAL];       //and save it",
	"      [self val_push yyval];           //also save the semantic value of parsing",
	"      if (basic.int(yychar) < 0)            //we want another character?",
	"        {",
	"        yychar = [self yylex];        //get next character",
	"        if (basic.int(yychar)<0) yychar=0;  //clean, if necessary",
	"        if (yydebug)",
	"          [self yylexdebug yystate, yychar];",
	"        }",
	"      if (basic.int(yychar) == 0)          //Good exit (if lex returns 0 ;-)",
	"         break;                 //quit the loop--all DONE",
	"      }//if yystate",
	"    else                        //else not done yet",
	"      {                         //get next state and push, for next yydefred[]",
	"      yyn = yygindex[yym];      //find out where to go",
	"      if ((yyn != 0) && (yyn += yystate) >= 0 &&",
	"            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)",
	"        yystate = yytable[yyn]; //get new state",
	"      else",
	"        yystate = yydgoto[yym]; //else go to new defred",
	"      [self debug \"after reduction, shifting from state \"+basic.repr([self state_peek 0])+\" to state \"+basic.repr(yystate)+\"\"];",
	"      [self state_push yystate];     //going again, so push state & val...",
	"      [self val_push yyval];         //for next action",
	"      }",
	"    }//main loop",
	"  return 0;//yyaccept!!",
	"}",
	"//## end of method parse() ######################################",
	"\n\n",
	"}",
	"//################### END OF CLASS ##############################",
	0
};


void write_section(const char *section[])
{
	int i;
	FILE *fp;

	fp = code_file;
	for (i = 0; section[i]; ++i)
	{
		++outline;
		if (strcmp(section[i], ELASTIC_PACKAGE) == 0)	/* elastiC package name, if any */
		{
			if (ec_package_name && strlen(ec_package_name) > 0)
				fprintf(fp, "package %s;\n", ec_package_name);
			fprintf(fp, "\nimport basic;\n");
			fprintf(fp, "import Token;\n");
		} else if (strcmp(section[i], ELASTIC_CLASS_DECL) == 0)
		{
			if (ec_class_name && strlen(ec_class_name) > 0)
				fprintf(fp, "public class %s\n", ec_class_name);
			else
				fprintf(fp, "public class Parser\n");
			if (ec_extends_name && strlen(ec_extends_name) > 0)
				fprintf(fp, "             extends %s\n", ec_extends_name);
			else
				fprintf(fp, "             extends basic.Object\n");
		} else
			fprintf(fp, "%s\n", section[i]);
	}
}
